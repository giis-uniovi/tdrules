# tdrules-store-loader

Populates a data store according to a TdSchema model. The main class
is `DataLoader` that uses an instance `IDataAdapter` (that issues sql commands to an rdb database or json
objects through an API).

## Quick start

Let `model` be a TdSchema model generated as indicated in the [tdrules-client-oa README](../tdrules-client-oa/README). 
Data loading consists on an instantiation of the Data Loader and a series of load commands:

### Step 1: Instantiate the DataLoader

To populate data into a server backend with an API accesible through the url `http://localhost/myapi`:
```java
DataLoader loader = new DataLoader(model, new OaLiveAdapter("http://localhost/myapi"));
```

To generate a script (either Postman or Zerocode) that can be stored and executed later:
```java
DataLoader loader = new DataLoader(model, new PostmanAdapter("http://localhost/myapi"));
DataLoader loader = new DataLoader(model, new ZerocodeAdapter("http://localhost/myapi"));
```

To populate data into a postgres database accesible through a jdbc connection `conn`, instantiate the Data Loader:
```java
DataLoader loader = new DataLoader(model, new SqlLiveAdapter(conn, "postgres"));
```

### Step2: Load data

Let `e1` and `e2` be two entities in `model`, each having the attribute `id` as the uid (autogenerated by the database/backend), 
and `e2` having the attribute `rid` that references `e1`.
Each entity has an additional number of attributes `a1`, `a2`, `a3`:

```java
loader.load("e1", "id=@id11, a1=10");
loader.load("e1", "id=@id12, a1=20");
loader.load("e2", "id=@id21, rid=@id11, a2=22");
```

Symbolic values (prefixed with `@`) are used to get backend generated data (to retrieve backend generated uids that are used in subsequent calls to fill the rids).

The above load sequence creates:
- two `e1` objects with the indicated values for `a1` and generated values for `a2` and `a3`.
- An `e2` object with the indicated value for `a2` and generated values for `a1` and `a2`.
- The symbolic value assigned to `rid` states that the attribute `rid` will be assigned to the
  value of the database/backend generated uid that corresponds to the second `e1` object.

## Data Adapters (IDataAdapter)

The TdSchema and the Data Adapter are the required parameters to instantiate a Data Loader.
Data Adapters implements the `IDataAdapter` interface and determines what kind of data is generated 
and where is sent to load:
- `OaLocalAdapter`: Generates a json object, but does not actually send the data.
- `OaLiveAdapter`: Generates a json object and submits a POST api call to the backend with this data.
  Path parameters to send attributes that are rid are supported.
- Script adapters: Generate scripts that later can be used to send the data to the backend service:
  - `PostmanAdapter`: The script is a [Postman](https://www.postman.com) collection
  - `ZerocodeAdapter`: The script is a [Zerocode](https://github.com/authorjapps/zerocode) scenario
- `SqlLocalAdapter`: Generates Sql statements only.
- `SqlLiveAdapter`: Generates Sql statements and executes them against an open jdbc connection to populate a database.

Live adapters require some parameters at instantiation time:
- `SqlLiveAdapter`: An open jdbc connection and the database vendor name
- `OaLiveAdapter`: The API url to send the POST requests. It supports several setters to inject custom implementations of internal components:
  - `ApiWriter`: By default, the post is sent to the url specified in the live adapter instantiation. 
    If you are not running E2E tests but you are mocking the network infrastructure, a custom `ApiWriter` can be used (e.g. to use Spring MockMvc)
  - `OaPathResolver`: By default, requests to insert data are made using the paths specified for POST in the OpenAPI model
    for the entity specified in the request body.
    If a path not available, uses the lowercase name of the entity as the path.
    A custom `OaPathResolver` can modify this behaviour.

## Generation of attribute values (IUidGen, IAttrGen)

As stated before, every value not specified in a `load` call is generated. 
Value generation is done differently if it is an uid or not by means of `IUidGen` and `IAttrGen` implementations 
that are injected into the `DataLoader` using setters.

Implementations of `IUidGen` to load uids are:
- `SequentialUidGen`:  Generate sequential uids in the frontend.
- `OaLiveUidGen`: Gets the backend autogenerated uid after a POST operation that returns the content of the object created.
- `SqlLiveUidGen`: Gets the autogenerated uid after inserting a row in a relational database.
- `LegacyUidGen`: Used for compatibility with legacy code: always returns a placeholder (`?`) as the last uid loadd.

Note that when generating scripts and the API generates uids in the backend, the `OaLiveUidGen` still has to be used.
In this case, the script will include the variables or jsonpath expressions required to identify the uids that are generated.

Implementations of `IAttrGen` to generate non uid primitive attribute values are:
- `DeterministicAttrGen`: This is the default implementation if no other is set.
  Generates values in a reproducible sequence, taking into account 
  the number of objects already created for each entity and the relative position of the attribute in each entity.
- `RandomAttrGen`: Generates random primitive attribute values.
- `DictionaryAttrGen`: Generates deterministic values from a set of dictionaries configured for
  coordinates defined by pairs entity/attribute; it also provides some
  formatting options (currently, only masking and padding).
  Values for attributes with no dictionary configured are generated using a `DeterministicAttrGen`.
