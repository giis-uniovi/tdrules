package giis.tdrules.store.loader.gen;

import java.util.List;

import giis.tdrules.model.shared.OaExtensions;
import giis.tdrules.openapi.model.TdSchema;
import giis.tdrules.store.dtypes.DataTypes;

/**
 * An IDataAdapter is used by DataGenerator to generate the appropriate object
 * according the model type (sql for relational database or json for openapi)
 * and to get the generated objects or update the database/service with the
 * generated object (called Live).
 *
 * Each object is generated by calling beginWrite followed by writeValue for
 * each attribute, ending with endWrite, that returns the string representation
 * of the object (sql or json).
 *
 * The generated objects are stored in a list that can be accessed with getAll.
 * For autogenerated keys, DataGenerator calls getLastAutogenerated which
 * accesses the database or to the api to obtain the necessary value.
 */
public interface IDataAdapter {

	/**
	 * Resets the adapter to its initial values
	 */
	void reset();
	
	/**
	 * Sets a a schema model that can be used to determine the paths.
	 */
	default IDataAdapter setSchemaModel(TdSchema model) {
		return this; // override if the adapter needs a model
	}

	/**
	 * Creates a new instance of a local adapter without data, used to process
	 * composite types by generating its data without executing API calls (in the
	 * case of a live adapter)
	 */
	IDataAdapter getNewLocalAdapter();

	/**
	 * Gets an instance of the key generator that is to be associated with all
	 * adapters by default
	 */
	IUidGen getDefaultUidGen();

	/**
	 * Gets the string representation of the last generated object
	 */
	String getLast();

	/**
	 * Gets the string representation of all objects that have been generated in all
	 * write operations
	 */
	List<String> getAll();

	/**
	 * Use this method instead getAll to check the data sent during testing
	 */
	default String getAllAsString() {
		return String.join("\n", getAll());
	}

	/**
	 * Gets the string representation of the backend response (empty if the backend
	 * does not return any data, default implementation). Used to get the backend
	 * generated uids
	 */
	default String getLastResponse() {
		return "";
	}

	/**
	 * Gets the last generated uid as determined by the uid generator
	 * (this method must be called after endWrite)
	 */
	default String getLastUid(IUidGen uidGen, String entityName, String attributeName) {
		return "";
	}

	/**
	 * Begins the write operation of an object in an entity
	 */
	void beginWrite(String entityName);

	/**
	 * Writes the value of an attribute with the specified data type
	 */
	void writeValue(String dataType, String attrName, String attrValue);

	/**
	 * Finish the writing of an object.
	 */
	void endWrite();

	// Determine the kind of data type given a data type string.
	// Default methods as every datatype is encoded in DataTypes
	// (each instance has its own implementation)

	/**
	 * Returns the DataTypes object that corresponds with the dbms name of the
	 * current instance. The dbms name should be initialized in the constructor
	 */
	DataTypes getDataTypes();

	default int getDataTypeId(String dataType) {
		return getDataTypes().getId(dataType);
	}

	/**
	 * Indicates is the data type is logical
	 */
	default boolean isBoolean(String dataType) {
		return getDataTypeId(dataType) == DataTypes.DT_LOGICAL;
	}

	/**
	 * Indicates if the data type is a string
	 */
	default boolean isString(String dataType) {
		return getDataTypeId(dataType) == DataTypes.DT_CHARACTER;
	}

	/**
	 * Indicates if the data type is a a free form object
	 */
	default boolean isFreeFormObject(String dataType) {
		return OaExtensions.FREE_FORM_OBJECT.equals(dataType);
	}

	/**
	 * Indicates if the data type is numeric (with or without decimals)
	 */
	default boolean isNumber(String dataType) {
		return getDataTypeId(dataType) == DataTypes.DT_INTEGER 
				|| getDataTypeId(dataType) == DataTypes.DT_EXACT_NUMERIC
				|| getDataTypeId(dataType) == DataTypes.DT_APPROXIMATE_NUMERIC;
	}

	/**
	 * Indicates if a number may contain decimal digits: When a number is exact
	 * numeric it uses the size string that represents the precision and scale in
	 * the TDM model (in the form precision,scale where the number has decimals if
	 * scale is greater than zero)
	 */
	default boolean hasDecimals(String dataType, String sizeString) {
		if (getDataTypeId(dataType) == DataTypes.DT_APPROXIMATE_NUMERIC)
			return true;
		else if (getDataTypeId(dataType) == DataTypes.DT_EXACT_NUMERIC) {
			if (sizeString == null || "".equals(sizeString))
				return false;
			String[] sizeSplit = sizeString.split(",");
			return (sizeSplit.length == 2 && !"".equals(sizeSplit[1]) && !"0".equals(sizeSplit[1]));
		}
		// everything else, including integer returns no decimals
		return false;
	}

	/**
	 * Indicates if the data type stores a date
	 */
	default boolean isDate(String dataType) {
		return getDataTypeId(dataType) == DataTypes.DT_DATE || getDataTypeId(dataType) == DataTypes.DT_DATETIME;
	}

}